<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>미리보기</title>
<script src="lib/jquery-3.2.1.min.js"></script>
<script src="lib/SmiEditor.js?241119"></script>
<script src="lib/SubtitleObject.js?241119"></script>
<script>
var SmiEditor = {};

var title = document.getElementsByTagName("title")[0];
var lastTab = null;
var time = 0;
var showText = [];
var hasLine = [];
var indexes = [];
var normalizedLines = [];
var normalizedIndex = [];

var style = null;
var setting = {}
function setSetting(jsonSetting) {
	setting = JSON.parse(jsonSetting);
	if (style == null) {
		$("head").append(style = $("<style>"));
	}
	style.html("#viewer {\n" + setting.viewer.css + "}");
}
var lines = [[],[],[]];
var viewer = null;
var viewers = [];
function setLines(newLines) {
	lines = JSON.parse(newLines);
	if (lines.length == 0) {
		lines.push([]);
	}
	normalizedLines = [];
	
	var receiveTime = time;
	time = -1;
	if (viewer) {
		viewer.empty();
		viewers = [];
		for (var i = 0; i < lines.length; i++) {
			viewer.append(viewers[i] = $("<div>"));
		}
	}
	refreshTime(receiveTime, true); // 내용 바꿀 땐 시간 표시는 갱신 X
}
function setTitle(text) {
	title.innerText = text;
}
var titleTime = -1;
function refreshTime(receiveTime, withoutTitle) {
	if (receiveTime != titleTime) {
		if (!withoutTitle) {
			var h = receiveTime;
			var ms = h % 1000; h = (h - ms) / 1000;
			var s  = h %   60; h = (h -  s) /   60;
			var m  = h %   60; h = (h -  m) /   60;
			setTitle("미리보기 - " + h + ":" + (m>9?"":"0")+m + ":" + (s>9?"":"0")+s + ":" + (ms>99?"":"0")+(ms>9?"":"0")+ms);
		}
		titleTime = receiveTime;
	}
	
	for (var hold = 0; hold < lines.length; hold++) {
		if (receiveTime < time || time < 0) {
			// 역방향 탐색일 경우 초기화
			indexes[hold] = -1;
			viewers[hold].empty();
		}
		// 현재 시간 이전의 가장 마지막 싱크 찾기
		var index = indexes[hold];
		for (var j = (indexes[hold] < 0 ? 0 : indexes[hold]); j < lines[hold].length; j++) {
			if (lines[hold][j][LINE.SYNC]) {
				if (lines[hold][j][LINE.SYNC] > receiveTime) {
					break;
				}
				index = j;
			}
		}
		if (index == indexes[hold]) {
			// 변화 없음
			if (normalizedLines[hold]) {
				// 현재 시간 이전의 가장 마지막 싱크 찾기
				var index = normalizedIndex[hold];
				for (var j = 0; j < normalizedLines[hold].length; j++) {
					if (normalizedLines[hold][j].start > receiveTime) {
						break;
					}
					index = j;
				}
				if (index == normalizedIndex[hold]) {
					// 변화 없음
				} else {
					setTextToView(normalizedLines[hold][normalizedIndex[hold] = index].text, hold);
					time = receiveTime;
				}
			}
			continue;
		}
		indexes[hold] = index;
		if (indexes[hold] < 0) {
			setTextToView("", hold);
			time = receiveTime;
			continue;
		}
		
		normalizedLines[hold] = null;
		hasLine[hold] = false;
		var showLines = [];
		var nextSyncLine = null;
		for (var j = indexes[hold] + 1; j < lines[hold].length; j++) {
			if (lines[hold][j][LINE.SYNC]) {
				nextSyncLine = lines[hold][j];
				break;
			}
			var line = lines[hold][j][LINE.TEXT].split(/<br>/gi);
			for (var k = 0; k < line.length; k++) {
				if (k == 0 || k < line.length - 1 || line[k].length) {
					showLines.push(line[k]);
				}
			}
		}
		// 줄표 있을 때 왼쪽 정렬
		if (setting.viewer.useAlign && showLines.length < 4) { // 줄 개수 제한 없으면 싱크 안 찍은 전체 내용에 대해 동작해버림
			for (var k = 0; k < showLines.length; k++) {
				if ($("<span>").html(showLines[k][0]).text()[0] == '-') {
					hasLine[hold] = true;
					break;
				}
			}
		}
		if (hasLine[hold]) {
			for (var j = 0; j < showLines.length; j++) {
				var line = showLines[j];
				if ($("<span>").html(line).text()[0] != '-') {
					line = "<span style='opacity: 0;'>-</span>" + line;
				}
				showLines[j] = line + "<span style='opacity: 0;'>-</span>";
			}
		}
		showText[hold] = showLines.join("<br>");
		
		// 정규화 자동 적용
		if (nextSyncLine && setting.saveWithNormalize) {
			var toNormalize = new Subtitle.SmiFile().fromTxt(lines[hold][indexes[hold]][LINE.TEXT] + "\n" + showText[hold] + "\n" + nextSyncLine[LINE.TEXT]);
			Subtitle.Smi.normalize(toNormalize.body);
			if (toNormalize.body.length > 2) {
				normalizedLines[hold] = toNormalize.body.slice(0, toNormalize.body.length - 1);
				showText[hold] = normalizedLines[hold][normalizedIndex[hold] = 0].text; // 일단은 첫 싱크 출력, 다음 루프에 추가로 잡아주기
			}
		}
		setTextToView(showText[hold], hold);
	}
	time = receiveTime;
};

function setTextToView(text, hold) {
	// RUBY태그 문법이 미묘하게 달라서 가공 필요
	text = text.split("<RP").join("<!--RP").split("</RP>").join("</RP-->");
	
	{	// 팟플레이어에선 공백문자 그대로 표시됨
		var a = text.split("<");
		a[0] = a[0].split(" ").join("&nbsp;");
		for (var j = 1; j < a.length; j++) {
			var b = a[j].indexOf(">");
			if (b >= 0) {
				a[j] = a[j].substring(0, b) + ">" + a[j].substring(b+1).split(" ").join("&nbsp;");
			}
		}
		text = a.join("<");
	}
	
	{	// font size도 추가 작업
		var j = 0;
		var begin = 0;
		while ((begin = text.toUpperCase().indexOf("<FONT", j)) >= 0) {
			if (begin > text.length) {
				break;
			}
			var end = text.indexOf(">", begin);
			if (end < 0) break;
			
			var tag = text.substring(begin, end);
			var index = tag.toUpperCase().indexOf("SIZE=");
			if (index > 0) {
				var q = tag[index + 5];
				var size = 0;
				var qEnd = 0;
				if (q == '"' || q == "'") {
					qEnd = tag.indexOf(q, index + 7);
					if (qEnd > 0) {
						try {
							size = Number(tag.substring(index + 6, qEnd));
							qEnd++;
						} catch (e) {}
					}
				} else {
					q = "";
				}
				if (size == 0) {
					var tmp = tag.substring(index + 5 + q.length);
					for (qEnd = index + 5 + q.length; qEnd < tag.length; qEnd++) {
						var c = tag[qEnd];
						if (isFinite(c)) {
							size = size * 10 + Number(c);
						} else {
							break;
						}
					}
				}
				if (size) {
					// 팟플레이어 기준 계산 
					var potSize = (window.innerWidth / 586) * size;
					
					// 크로뮴에서 10보다 작으면 제대로 안 보임
					// 이런 크기는 사실상 흔들기 기능 공백으로만 쓰임
					//if (potSize < 10) potSize += 50;
					
					var style = 'style="font-size: ' + potSize + 'px;"';
					text = text.substring(0, begin + index) + style + text.substring(begin + qEnd);
					end = end - qEnd + index + style.length;
				}
			}
			j = end;
		}
	}
	
	{	// 흔들기 효과 상하 공백줄 처리 -> 맨 윗줄만
		var showLines = text.split(/<br>/gi);
		if (lines[hold].length > 2) {
			var line = showLines;
			if ($("<span>").html(line).text() == "　") {
				if (line.indexOf("font-size:") > 0) {
					showlines[hold] = line.split("<font style=\"font-size:").join("<div style=\"height:").split("</font>").join("</div>");
				}
			}
		}
		text = showLines.join("<br>");
	}
	
	// 비어있으면 높이 차지하지 않게 내용 없애기
	if (!text.split("&nbsp;").join(" ").trim().length) {
		text = "";
	}
	
	var viewer = viewers[hold].html(text);
	if (hasLine[hold]) {
		viewer.addClass("has-line");
	} else {
		viewer.removeClass("has-line");
	}
}

$(function() {
	viewer = $("#viewer");
	if (opener) {
		SmiEditor = opener.SmiEditor;
		opener.binder.updateViewerSetting();
	} else if (binder && binder.onloadViewer) {
		binder.onloadViewer();
	}
});

$(document).on("keydown", function(e) {
	switch (e.keyCode) {
		case 37: { // ←
			if (!e.shiftKey && !e.ctrlKey && e.altKey) {
				// 뒤로
				e.preventDefault();
				SmiEditor.PlayerAPI.move(-SmiEditor.sync.move);
				SmiEditor.PlayerAPI.play();
			}
			break;
		}
		case 39: { // →
			if (!e.shiftKey && !e.ctrlKey && e.altKey) {
				// 앞으로
				e.preventDefault();
				SmiEditor.PlayerAPI.move(SmiEditor.sync.move);
				SmiEditor.PlayerAPI.play();
			}
			break;
		}
		case 120: { // F9: 재생/일시정지
			e.preventDefault();
			SmiEditor.PlayerAPI.playOrPause();
			break;
		}
		case 121: { // F10: 재생
			e.preventDefault();
			SmiEditor.PlayerAPI.play();
			break;
		}
		case 122: { // F11: 정지
			e.preventDefault();
			SmiEditor.PlayerAPI.stop();
			break;
		}
	}
});
</script>
<style>
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}
html, body {
	width: 100%;
	height: 100%;
}
#viewer {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	text-align: center;
}
#viewer div.has-line {
	text-align: left;
	width: fit-content;
	margin: 0 auto;
}
</style>
</head>
<body>
	<div id="viewer"></div>
</body>
</html>